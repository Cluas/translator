# 从头开始在 Go 中设计一个无密码的登录系统

- 原文地址：https://abhik.hashnode.dev/designing-a-password-less-login-system-in-go-from-scratch
- 原文作者：Abhik Banerjee
- 本文永久链接：https://github.com/gocn/translator/blob/master/2022/w36_Designing_a_Password-less_Login_System_in_Go_from_scratch.md
- 译者：[Cluas](https://github.com/Cluas)
- 校对：
  

无密码登录是一种误导性的说法，因为在任何认证步骤中都会以这样或那样的方式涉及密码。即使是在生物识别系统中，你的生物识别技术也充当了密码。无密码的概念是围绕着为用户创建临时密码而展开的。以达到减少攻击面的目的。请放心，如果密码每次都改变，那么攻击者将不得不获得用户的邮箱账号或手机号来破解系统。

本文是系列博客的一部分，我们将从头开始构建无密码认证系统的后端和前端。这里使用的代码不应该被用作任何项目的种子代码，因为项目本身只是对范式的工作进行了研究。

如果你想要一个更具体的实现或模块，我推荐你去看看[Authboss](https://github.com/volatiletech/authboss)。它是一套完整的产品，供 `Go` 开发者在他们的系统中集成安全认证。

在这篇文章中，我们将深入探讨我们系统的设计。这篇文章不会是代码密集型的，这意味着目的只是让你了解我们将在以后的博客中构建的内容。

## 技术栈

对于后端，我们将使用以下内容：

1.  `Go` - 来构建后端
2.  `MongoDB` - 来存储用户资料
3.  `Redis` - 来存储 `OTPs`(One-time password 一次性密码)


很简单，对吧？我现在还不会讨论前端技术栈，因为我觉得很矛盾。一方面，用 React 构建前端技术栈是很容易而且可能是小众的。另一方面，我很想探索 Rust 提供的东西。所以让我们暂时把这个问题放在一边。
## 设计

该系统由两部分组成--注册机制和登录机制。为了保持重点关注，我们将不会超越这一点。如果你愿意，你可以尝试复制这些东西并将其添加到你的 Todo 列表应用程序中 :)

### 注册阶段

![Password-less Signup flow](../static/images/2022/w36_Designing_a_Password-less_Login_System_in_Go_from_scratch/Password-less_Signup_flow.avif)

注册阶段将包括以下步骤：

1.  用户通过 `API` `ping` 后端，并发送用户的资料信息。
2.  后端查询 `MongoDB` 以检查是否存在这样的资料。
3.  `MongoDB` 结果返回 `nil`，因为这将是一个新的用户。
4.  后端发送个人资料以存储在 `MongoDB` 中。
5.  它存储一个 `OTP`，用于用户的资料验证。
6.  后端向用户发送通知，称 `OTP` 已被发送到用户的 邮箱/手机号。

然后，用户需要检查他/她/它（不想冒犯任何正在阅读的机器人），并输入 OTP。这就完成了注册的流程，用户的资料得到了验证。

#### 锦上添花
你可以把它提高一个档次，实施以下机制：

1. 如果用户在 `X` 个小时内没有验证，那么该用户资料就会被删除，用户需要再次通过流程。这将需要一个定时运行的 `cronjob` 来清除未验证的资料。
2. 考虑上述步骤的另一种可能的方式是将用户的配置文件存储在 `Redis` 中并设置一个过期标签。一旦用户验证了，就把它移到 `MongoDB` 上。

### 登陆阶段

![Passwordless signin](../static/images/2022/w36_Designing_a_Password-less_Login_System_in_Go_from_scratch/Passwordless_signin.avif)

这个步骤与上面的流程很相似。在这种情况下，步骤将是：

1. 用户用 邮箱/手机号 向后端服务器 `API` 发出请求。
2. 后端服务器检查是否有与给定的 邮箱/手机号 相关的个人资料。
3. `MongoDB` 的搜索要么产生一个 `true`，要么产生一个`false`。
4. 如果是`false`，用户将需要通过注册流程。在前端，这将意味着将被重新引导到注册页面。如果是在后端，这将会报错并停止流程。
5. 如果 `MongoDB` 搜索产生一个`true`，就会产生一个即将到期的 `OTP` 并存储在 `Redis` 中。
6. `OTP` 被发送到用户的邮箱/手机，并注明它在X秒/小时后失效。
7. 用户输入 `OTP`，并被送回一个认证令牌。

### 额外流程

除此以外，我们将为以下内容建立 `API` 端点：

1. 浏览那些将自己的资料公开的用户。
2. 改变当前用户的个人资料细节。

我们可以在这里疯狂地实现好友请求设置。但我们会把它保留到将来。

## 总结

很遗憾，目前的文章到此结束。该系列文章的所有代码都将在 GitHub 上公开。在下一篇文章中，我们将设计路由/端点并为数据库安排连接。之后的文章将看到这些端点的控制器的实现。

我正在从我通常的区块链主题文章中休息一下，在这段时间里，我很想发表一些有趣的文章，比如上面讨论的那些。如果你喜欢这篇文章并希望关注这个系列，请随时订阅我的通讯并留下反应。直到下一次，继续建造令人敬畏的东西和 WAGMI（**We All Gonna Make It**  **我们都会成功的**）!